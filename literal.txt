#include <stdio.h> 
#include <ctype.h>    
#include <string.h> 
 
char keywords[32][8] = { 
 "auto", "break", "case", "char", "const", "continue", "default", "do", 
 "double", "else", "enum", "extern", "float", "for", "goto", "if", 
 "int", "long", "register", "return", "short", "signed", "sizeof", 
 "static", "struct", "switch", "typedef", "union", "unsigned", "void", 
 "volatile", "while" 
}; 
 
int isKeyword(char *str) { 
 for (int i = 0; i < 32; i++) { 
     if (strcmp(str, keywords[i]) == 0) 
         return 1; 
 } 
 return 0; 
} 
 
int isSeparator(char ch) { 
 return ch == '(' || ch == ')' || ch == ' ' || ch == '{'|| ch == '}' || 
        ch == ';' || ch == ',' || ch == '[' || ch == ']'; 
} 
 
int isOperator(char ch) { 
 return ch == '+' || ch == '-' || ch == '*' || ch == '/' || 
        ch == '%' || ch == '=' || ch == '<' || ch == '>' || ch == '!'; 
} 
 
void lexicalAnalyzer(FILE *fp) { 
 char ch, buffer[100], next_ch; 
 int i = 0;                   
 
 while ((ch = fgetc(fp)) != EOF) { 
     // Check for single-line comment (//) 
     if (ch == '/') { 
         next_ch = fgetc(fp); // Read next character 
         if (next_ch == '/') { 
             // It's a single-line comment, skip until newline or EOF 
             while ((ch = fgetc(fp)) != '\n' && ch != EOF); 
             continue; // Continue to next character after the comment 
         } else if (next_ch == '*') { 
             // It's a multi-line comment (/* ... */) 
             while (1) { 
                 ch = fgetc(fp); 
                 if (ch == '*') { 
                     next_ch = fgetc(fp); 
                     if (next_ch == '/') { 
                         break; 
                     } else { 
                         ungetc(next_ch, fp); 
                     } 
                 } 
                 if (ch == EOF) { 
                     // Handle unterminated multi-line comment at EOF 
                     fprintf(stderr, "Error: Unterminated multi-line comment.\n"); 
                     return; 
                 } 
             } 
             continue; 
         } 
     } 
     // --- Handle String Literals --- 
     if (ch == '"') { 
         buffer[i++] = ch; 
         while ((ch = fgetc(fp)) != '"' && ch != EOF && ch != '\n') { 
             buffer[i++] = ch; 
         } 
         if (ch == '"') { 
             buffer[i++] = ch; 
         } else { 
             // Handle unterminated string literal 
             fprintf(stderr, "Error: Unterminated string literal.\n"); 
             if (ch != EOF && ch != '\n') ungetc(ch, fp); 
         } 
         buffer[i] = '\0'; // Null-terminate the buffer 
         i = 0;         // Reset buffer index 
         printf("<STRING_LITERAL> %s\n", buffer); 
         continue; 
     } 
 
     // --- Ignore Whitespace --- 
     if (isspace(ch)) { 
         continue; 
     } 
 
     // --- Handle Identifiers or Keywords --- 
     if (isalpha(ch) || ch == '_') { 
         buffer[i++] = ch; // Start building the lexeme 
         while (isalnum(next_ch = fgetc(fp)) || next_ch == '_') { 
             buffer[i++] = next_ch; 
         } 
         buffer[i] = '\0'; 
         i = 0;         
         ungetc(next_ch, fp); 
 
         if (isKeyword(buffer)) { 
             printf("<KEYWORD> %s\n", buffer); 
         } else { 
             printf("<IDENTIFIER> %s\n", buffer); 
         } 
     } 
     // --- Handle Numbers (Integers and Floats) --- 
     else if (isdigit(ch)) { 
         buffer[i++] = ch; 
         while (isdigit(next_ch = fgetc(fp)) || next_ch == '.') { 
             buffer[i++] = next_ch; 
         } 
         buffer[i] = '\0'; 
         i = 0;          
         ungetc(next_ch, fp); 
         printf("<NUMBER> %s\n", buffer); 
     } 
     // --- Handle Operators --- 
     else if (isOperator(ch)) { 
         next_ch = fgetc(fp); 
         if ((ch == '=' && next_ch == '=') || 
             (ch == '!' && next_ch == '=') || 
             (ch == '<' && next_ch == '=') || 
             (ch == '>' && next_ch == '=')) { 
             printf("<OPERATOR> %c%c\n", ch, next_ch); 
         } 
         else if(ch == '=' &&  next_ch != '='){ 
             printf("<ASSIGNEMT OPERATOR> %c\n", ch); 
             ungetc(next_ch, fp); 
         } 
         else{ 
          printf("<OPERATOR> %c\n", ch); 
             ungetc(next_ch, fp); 
         } 
     } 
     // --- Handle Separators --- 
     else if (isSeparator(ch)) { 
         printf("<SEPARATOR> %c\n", ch); 
     } 
     // --- Handle Unrecognized Characters --- 
     else { 
         fprintf(stderr, "Warning: Unrecognized character '%c'\n", ch); 
         break; 
     } 
 } 
} 
int main() { 
FILE *fp = fopen("testcased1.c", "r"); // Open the input file 
if (fp == NULL) { 
printf("Error: Could not open file 'testcase.c'. Please ensure it exists.\n"); 
return 1; 
} 
printf("Tokens:\n--------\n"); 
lexicalAnalyzer(fp); 
fclose(fp);      
return 0; 
}